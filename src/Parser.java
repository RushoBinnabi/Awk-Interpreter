/**
 * Name: Rusho Binnabi
 * Date: 9/15/2023
 * Assignment: Parser 1
 * Class: ICSI 311 - Fall 2023
 */

import java.util.Collection;
import java.util.LinkedList;
import java.util.Optional;

import static java.lang.Boolean.FALSE;
import static java.lang.Boolean.TRUE;

public class Parser {

    // this Parser class will turn the list of tokens generated by the Lexer into a tree.

    private final LinkedList<Token> tokenList;
    private TokenHandler tokenHandler;

    private int acceptSeparatorsMethodState = 1;
    private boolean separatorFound;
    private boolean parseFunctionTrueFalse;
    private boolean parseActionTrueFalse;
    
    /**
     * this Parser() constructor initializes the values for the tokenList Linked List and tokenHandler Token Handler objects.
     * @param tL the argument is the list of tokens from the lexer.
     */
    public Parser(LinkedList<Token> tL) {
        tokenList = new LinkedList<>(tL);
        tokenHandler = new TokenHandler(tL);
    }

    /**
     * this getTokenList() method gets the token list that was used by the tree.
     * @param i the token that will be returned from the linked list.
     * @return a token from the token list.
     */

    public Token.TokenType getTokenList(int i) {
        return tokenList.get(i).getTokenType();
    }

    /**
     * this getParseActionTrueFalse() method gets the boolean value for the parseAction() method.
     * @return true if actions parsed correctly, false otherwise.
     */
    public boolean getParseActionTrueFalse() {
        return parseActionTrueFalse;
    }

    /**
     * this setParseActionTrueFalse() method sets the boolean value for the parseAction() method.
     * @param action true if actions parsed correctly, false otherwise.
     */

    public void setParseActionTrueFalse(boolean action) {
        parseActionTrueFalse = action;
    }

    /**
     * this getParseFunctionTrueFalse() method gets the boolean value for the parseFunction() method.
     * @return true if functions parsed correctly, false otherwise.
     */

    public boolean getParseFunctionTrueFalse() {
        return parseFunctionTrueFalse;
    }

    /**
     * this setParseFunctionTrueFalse() method sets the boolean value for the parseFunction() method.
     * @param function true if functions parsed correctly, false otherwise.
     */

    public void setParseFunctionTrueFalse(boolean function) {
        parseFunctionTrueFalse = function;
    }

    /**
     * this getSeparatorFound() method gets the boolean value for the acceptSeparators() method.
     * @return true if separators were accepted, false otherwise.
     */

    public boolean getSeparatorFound() {
        return separatorFound;
    }

    /**
     * this setSeparatorFound() method sets the boolean value for the acceptSeparators() method.
     * @param found if separators were accepted, false otherwise.
     */

    public void setSeparatorFound(boolean found) {
        separatorFound = found;
    }

    /**
     * this setAcceptSeparatorsMethodState() method sets the integer variable for the state machine for the acceptSeparators() method.
     * @param i sets to states 1 or 2 depending on whether there is one or more semicolon or new line.
     */

    public void setAcceptSeparatorsMethodState(int i) {
        acceptSeparatorsMethodState = i;
    }

    /**
     * this getAcceptSeparatorsMethodState() method gets the state of the state machine for the acceptSeparators() method.
     * @return 1 or 2 depending on what state the state machine is in.
     */

    public int getAcceptSeparatorsMethodState() {
        return acceptSeparatorsMethodState;
    }

    /**
     * this setTokenHandler() method sets the token handler object.
     * @param t the token handler object.
     */

    public void setTokenHandler(TokenHandler t) {
        tokenHandler = t;
    }

    /**
     * this getTokenHandler() method gets the token handler object, so it can be used.
     * @return the token handler object.
     */

    public TokenHandler getTokenHandler() {
        return tokenHandler;
    }

    /**
     * this acceptSeparators() method accepts any number of separators, whether that be new lines or semicolons,
     * and returns true if it finds at least one.
     * @param i the number of separators.
     * @return true if it finds at least one new line or semicolon, false otherwise.
     */

    public boolean acceptSeparators(int i) {
        while (getAcceptSeparatorsMethodState() == 1 || getAcceptSeparatorsMethodState() == 2) {
            if (getAcceptSeparatorsMethodState() == 1) {
                while (getTokenHandler().moreTokens() == FALSE) {
                    if ((getTokenList(i).toString().equals(",") && getTokenList(i).toString().equals("}")) || (getTokenList(i).toString().equals("\n") || getTokenList(i).toString().equals(";"))) {
                        getTokenHandler().matchAndRemove(getTokenList(i));
                    }
                    setSeparatorFound(true);
                }
                setAcceptSeparatorsMethodState(2);
            }
            else if (getAcceptSeparatorsMethodState() == 2) {
                if (getTokenHandler().moreTokens() == TRUE) {
                    setAcceptSeparatorsMethodState(1);
                    setSeparatorFound(false);
                }
            }
        }
        return getSeparatorFound();
    }

    /**
     * this parse() method loops through calling the parseFunction() and parseAction() methods
     * and if neither of them returns true, it throws an exception.
     * @return a program node.
     */

    public ProgramNode parse() {
        ProgramNode programNode = null;
        try {
            while (getTokenHandler().moreTokens() == FALSE) {
                if (parseFunction(programNode) == FALSE) {
                    throw new Exception();
                }
                else if (parseAction(programNode) == FALSE) {
                    throw new Exception();
                }
                else {
                    programNode = new ProgramNode();
                }
            }
        }
        catch (Exception e) {
            System.out.println("Error. Unknown item found.");
        }
        return programNode;
    }

    /**
     * this parseFactor() method checks for tokens for factors and accepts them appropriately
     * and tries to make an OperationNode out of them or if it can't, then it returns a partial result.
     * @return an OperationNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */

    Optional<Token> parseFactor() throws Exception {
        Optional<Token> num = getTokenHandler().matchAndRemove(Token.TokenType.NUMBER);
        if (num.isPresent()) {
            return num;
        }
        if (getTokenHandler().matchAndRemove(Token.TokenType.LEFTPARENTHESIS).isPresent()) {
            Optional<Token> exp = parseExpression();
            if (!exp.isPresent()) {
                throw new Exception();
            }
            if (getTokenHandler().matchAndRemove(Token.TokenType.RIGHTPARENTHESIS).isPresent()) {
                throw new Exception();
            }
        }
        return Optional.empty();
    }

    /**
     * this parseTerm() method checks for tokens for terms and accepts them appropriately
     * and tries to make an OperationNode out of them or if it can't, then it returns a partial result.
     * @return an OperationNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */

    Optional<Token> parseTerm() throws Exception {
        Optional<Token> left = parseFactor();
        do {
            Optional<Token> op = getTokenHandler().matchAndRemove(Token.TokenType.TIMES);
            if (op.isPresent()) {
                op = getTokenHandler().matchAndRemove(Token.TokenType.DIVIDE);
            }
            if (op.isPresent()) {
                return left;
            }
            Optional<Token> right = parseFactor();
            left = new OperationNode(left, op, right);
        } while (true);
    }

    /**
     * this parseExpression() method checks for tokens for expression and accepts them appropriately
     * and tries to make an OperationNode out of them or if it can't, then it returns a partial result.
     * @return an OperationNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */
    Optional<Token> parseExpression() throws Exception {
        Optional<Token> left = parseTerm();
        do {
            Optional<Token> op = getTokenHandler().matchAndRemove(Token.TokenType.PLUS);
            if (op.isPresent()) {
                op = getTokenHandler().matchAndRemove(Token.TokenType.MINUS);
            }
            if (op.isPresent()) {
                return left;
            }
            Optional<Token> right = parseTerm();
            left = new OperationNode(left, op, right);
        } while (true);
    }

    /**
     * this parseArray() method checks for tokens for arrays and accepts them appropriately
     * and tries to make an OperationNode out of them or if it can't, then it returns a partial result.
     * @return an OperationNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */

    Optional<Token> parseArray() throws Exception {
        Optional<Token> left = parseExpression();
        do {
            Optional<OperationNode.Operations> array = Optional.of(OperationNode.Operations.OPENARRAY);
            if (array.toString().isEmpty()) {
                throw new Exception();
            }
            else {
                array = Optional.of(OperationNode.Operations.CLOSEARRAY);
                if (!array.toString().isEmpty()) {
                    return Optional.of(left.get());
                }
            }
            Optional<Token> right = parseExpression();
            left = new OperationNode(left, array.get(), right);
        } while (true);
    }

    /**
     * this parseTernary() method checks for tokens for ternary's and accepts them appropriately
     * and tries to make an OperationNode out of them or if it can't, then it returns a partial result.
     * @return a TernaryNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */

    Optional<Node> parseTernary() throws Exception {
        Optional<Node> condition = Optional.empty();
        Optional<Node> consequent; // true case.
        Optional<Node> alternate; // false case.
        do {
            if (!parseLogicalOR().toString().equals(getTokenHandler().matchAndRemove(Token.TokenType.QUESTIONMARK).toString())) {
                throw new Exception();
            }
            else if (parseLogicalOR().toString().equals(getTokenHandler().matchAndRemove(Token.TokenType.QUESTIONMARK).toString())) {
                consequent = parseLogicalOR();
                alternate = parseLogicalOR();
                TernaryNode ternaryNode = new TernaryNode(condition.get(), consequent.get(), alternate.get());
                return Optional.of(ternaryNode);
            }
        } while (true);
    }

    /**
     * this parseAssignment() method checks for tokens for assignment and accepts them appropriately
     * and tries to make an AssignmentNode out of them or if it can't, then it returns a partial result.
     * @return an AssignmentNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */

    Optional<Node> parseAssignment() throws Exception {
        Optional<Node> target;
        Optional<Node> expression;
        do {
            if (!parseTernary().toString().equals(getTokenHandler().matchAndRemove(Token.TokenType.ASSIGNMENT).toString()) ||
                    !parseTernary().toString().equals(OperationNode.Operations.EXPONENT.toString()) ||
                    !parseTernary().toString().equals(OperationNode.Operations.MODULO.toString()) ||
                    !parseTernary().toString().equals(OperationNode.Operations.MULTIPLY.toString()) ||
                    !parseTernary().toString().equals(OperationNode.Operations.DIVIDE.toString()) ||
                    !parseTernary().toString().equals(OperationNode.Operations.ADD.toString()) ||
                    !parseTernary().toString().equals(OperationNode.Operations.SUBTRACT.toString())) {
                throw new Exception();
            }
            else if (parseTernary().toString().equals(getTokenHandler().matchAndRemove(Token.TokenType.ASSIGNMENT).toString())) {
                target = parseTernary();
                expression = parseTernary();
                AssignmentNode assignmentNode = new AssignmentNode(target.get(), new OperationNode(target.get(), null, Optional.of(expression.get())));
                return Optional.of(assignmentNode);
            }
            else if (parseTernary().toString().equals(OperationNode.Operations.EXPONENT.toString())) {
                target = parseTernary();
                expression = parseTernary();
                AssignmentNode assignmentNode = new AssignmentNode(target.get(), new OperationNode(target.get(), null, Optional.of(expression.get())));
                return Optional.of(assignmentNode);
            }
            else if (parseTernary().toString().equals(OperationNode.Operations.MODULO.toString())) {
                target = parseTernary();
                expression = parseTernary();
                AssignmentNode assignmentNode = new AssignmentNode(target.get(), new OperationNode(target.get(), null, Optional.of(expression.get())));
                return Optional.of(assignmentNode);
            }
            else if (parseTernary().toString().equals(OperationNode.Operations.MULTIPLY.toString())) {
                target = parseTernary();
                expression = parseTernary();
                AssignmentNode assignmentNode = new AssignmentNode(target.get(), new OperationNode(target.get(), null, Optional.of(expression.get())));
                return Optional.of(assignmentNode);
            }
            else if (parseTernary().toString().equals(OperationNode.Operations.DIVIDE.toString())) {
                target = parseTernary();
                expression = parseTernary();
                AssignmentNode assignmentNode = new AssignmentNode(target.get(), new OperationNode(target.get(), null, Optional.of(expression.get())));
                return Optional.of(assignmentNode);
            }
            else if (parseTernary().toString().equals(OperationNode.Operations.ADD.toString())) {
                target = parseTernary();
                expression = parseTernary();
                AssignmentNode assignmentNode = new AssignmentNode(target.get(), new OperationNode(target.get(), null, Optional.of(expression.get())));
                return Optional.of(assignmentNode);
            }
            else if (parseTernary().toString().equals(OperationNode.Operations.SUBTRACT.toString())) {
                target = parseTernary();
                expression = parseTernary();
                AssignmentNode assignmentNode = new AssignmentNode(target.get(), new OperationNode(target.get(), null, Optional.of(expression.get())));
                return Optional.of(assignmentNode);
            }
        } while (true);
    }

    /**
     * this parseLogicalAND() method checks for tokens for logical and's and accepts them appropriately
     * and tries to make an OperationNode out of them or if it can't, then it returns a partial result.
     * @return an OperationNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */
    Optional<Node> parseLogicalAND() throws Exception {
        Optional<Node> left = parseArray();
        do {
            if (!left.isPresent()) {
                throw new Exception();
            }
            Optional<Token> and = getTokenHandler().matchAndRemove(Token.TokenType.CONDITIONALAND);
            if (and.isPresent()) {
                return Optional.of(left.get());
            }
            Optional<Node> right = parseArray();
            left = new OperationNode(left.get(), and, right);
        } while (true);
    }

    /**
     * this parseLogicalOR() method checks for tokens for logical or's and accepts them appropriately
     * and tries to make an OperationNode out of them or if it can't, then it returns a partial result.
     * @return an OperationNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */

    Optional<Node> parseLogicalOR() throws Exception {
        Optional<Node> left = parseLogicalAND();
        do {
            if (!left.isPresent()) {
                throw new Exception();
            }
            Optional<Token> or = getTokenHandler().matchAndRemove(Token.TokenType.CONDITIONALOR);
            if (or.isPresent()) {
                return left;
            }
            Optional<Node> right = parseLogicalAND();
            left = new OperationNode(left.get(), or, right);
        } while (true);
    }

    /**
     * this parseExponents() method checks for tokens for exponents and accepts them appropriately
     * and tries to make an OperationNode with right associativity out of them or if it can't, then it returns a partial result.
     * @return an OperationNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */

    Optional<Node> parseExponents() throws Exception {
        Optional<Node> right = parseBottomLevel();
        do {
            if (!right.isPresent()) {
                throw new Exception();
            }
            else if (right.toString().equals(getTokenHandler().matchAndRemove(Token.TokenType.EXPONENT).toString())) {
                OperationNode op = new OperationNode(null, OperationNode.Operations.EXPONENT, Optional.of(right.get()));
                return Optional.of(op);
            }
        } while (true);
    }

    /**
     * this parseConcatenation() method checks for tokens for string concatenation and accepts them appropriately
     * and tries to make an OperationNode with left associativity out of them or if it can't, then it returns a partial result.
     * @return an OperationNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */

    Optional<Node> parseConcatenation() throws Exception {
        Optional<Token> left = parseExpression();
        do {
            if (!left.isPresent()) {
                throw new Exception();
            }
            else if (left.toString().equals(getTokenHandler().matchAndRemove(Token.TokenType.CONCATENATION).toString())) {
                OperationNode op = new OperationNode(left, OperationNode.Operations.CONCATENATION, null);
                return Optional.of(op);
            }
        } while (true);
    }

    /**
     * this parseBooleanCompare() method checks for tokens for boolean compares and accepts them appropriately
     * and tries to make an OperationNode with no associativity out of them or if it can't, then it returns a partial result.
     * @return an OperationNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */

    Optional<Node> parseBooleanCompare() throws Exception {
        if (getTokenHandler().matchAndRemove(Token.TokenType.LESSTHAN).isPresent()) {
            OperationNode op = new OperationNode(parseBooleanCompare().get(), OperationNode.Operations.LT, Optional.of(parseBooleanCompare().get()));
            return Optional.of(op);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.LESSTHANOREQUALTO).isPresent()) {
            OperationNode op = new OperationNode(parseBooleanCompare().get(), OperationNode.Operations.LE, Optional.of(parseBooleanCompare().get()));
            return Optional.of(op);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.NOTEQUALTO).isPresent()) {
            OperationNode op = new OperationNode(parseBooleanCompare().get(), OperationNode.Operations.NE, Optional.of(parseBooleanCompare().get()));
            return Optional.of(op);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.EQUALS).isPresent()) {
            OperationNode op = new OperationNode(parseBooleanCompare().get(), OperationNode.Operations.EQ, Optional.of(parseBooleanCompare().get()));
            return Optional.of(op);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.GREATERTHAN).isPresent()) {
            OperationNode op = new OperationNode(parseBooleanCompare().get(), OperationNode.Operations.GT, Optional.of(parseBooleanCompare().get()));
            return Optional.of(op);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.GREATERTHANOREQUALTO).isPresent()) {
            OperationNode op = new OperationNode(parseBooleanCompare().get(), OperationNode.Operations.GE, Optional.of(parseBooleanCompare().get()));
            return Optional.of(op);
        }
        else {
            throw new Exception();
        }
    }

    /**
     * this parseMatch() method checks for tokens for ERE matches or non-matches and accepts them appropriately
     * and tries to make an OperationNode with no associativity out of them or if it can't, then it returns a partial result.
     * @return an OperationNode based on appropriate tokens or returns a partial result.
     * @throws Exception if a token doesn't exist.
     */

    Optional<Node> parseMatch() throws Exception {
        if (getTokenHandler().matchAndRemove(Token.TokenType.MATCH).isPresent()) {
            OperationNode op = new OperationNode(parseMatch().get(), OperationNode.Operations.MATCH, Optional.of(parseMatch().get()));
            return Optional.of(op);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.DOESNOTMATCH).isPresent()) {
            OperationNode op = new OperationNode(parseMatch().get(), OperationNode.Operations.NOTMATCH, Optional.of(parseMatch().get()));
            return Optional.of(op);
        }
        else {
            throw new Exception();
        }
    }

    /**
     * this parseBottomLevel() method tries to parse from the bottom levels, and it looks at the token values for STRINGLITERAL, NUMBER, PATTERN, etc.,
     * and depending on if they exist, constant nodes, pattern nodes, operation nodes, etc., may be created with or without
     * the result of other types of parsing methods and operation token types.
     * @return pattern nodes, constant nodes, operation nodes, otherwise, it returns the return value of the parseLValue() method.
     */

    Optional<Node> parseBottomLevel() {
        VariableReferenceNode variableReferenceNode = new VariableReferenceNode(null, null);
        if (getTokenHandler().matchAndRemove(Token.TokenType.NUMBER).isPresent()) {
            ConstantNode constantNode = new ConstantNode(Integer.parseInt(variableReferenceNode.getIndexExpression().toString()));
            return Optional.of(constantNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.REGULAREXPRESSIONPATTERN).isPresent()) {
            PatternNode patternNode = new PatternNode(variableReferenceNode.getIndexExpression().toString());
            return Optional.of(patternNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.LEFTPARENTHESIS).isPresent()) {
            Optional<Node> op = parseOperation();
            if (getTokenHandler().matchAndRemove(Token.TokenType.RIGHTPARENTHESIS).isPresent()) {
                return op;
            }
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.NOT).isPresent()) {
            Optional<Node> op = parseOperation();
            OperationNode operationNode = new OperationNode(op.get(), OperationNode.Operations.NOT, null);
            return Optional.of(operationNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.MINUS).isPresent()) {
            Optional<Node> op = parseOperation();
            OperationNode operationNode = new OperationNode(op.get(), OperationNode.Operations.UNARYNEG, null);
            return Optional.of(operationNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.PLUS).isPresent()) {
            Optional<Node> op = parseOperation();
            OperationNode operationNode = new OperationNode(op.get(), OperationNode.Operations.UNARYPOS, null);
            return Optional.of(operationNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.INCREMENT).isPresent()) {
            Optional<Node> op = parseOperation();
            OperationNode operationNode = new OperationNode(op.get(), OperationNode.Operations.PREINC, null);
            return Optional.of(operationNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.DECREMENT).isPresent()) {
            Optional<Node> op = parseOperation();
            OperationNode operationNode = new OperationNode(op.get(), OperationNode.Operations.PREDEC, null);
            return Optional.of(operationNode);
        }
        else {
            try {
                if (parseFunctionCall() != null) {
                    return Optional.of(parseFunctionCall());
                }
            }
            catch (Exception e) {
                System.out.println("Error. The function call could not be parsed.");
            }
            return Optional.of(parseLValue()).get();
        }
        return Optional.empty();
    }

    /**
     * this parsePostIncrementDecrement() method checks for tokens for exponents and accepts them appropriately
     * and tries to make an OperationNode out of them or if it can't, then it returns a partial result.
     * @return an OperationNode based on appropriate tokens or returns a partial result.
     */

    Optional<Node> parsePostIncrementDecrement() {
        if (parseBottomLevel().isPresent()) {
            if (getTokenHandler().matchAndRemove(Token.TokenType.INCREMENT).isPresent()) {
                OperationNode operationNode = new OperationNode(parseBottomLevel().get(), OperationNode.Operations.POSTINC, null);
                return Optional.of(operationNode);
            }
            else if (getTokenHandler().matchAndRemove(Token.TokenType.DECREMENT).isPresent()) {
                OperationNode operationNode = new OperationNode(parseBottomLevel().get(), OperationNode.Operations.POSTDEC, null);
                return Optional.of(operationNode);
            }
            else {
                return Optional.of(parseBottomLevel().get());
            }
        }
        return Optional.empty();
    }

    /**
     * this parseLValue() method tries to parse left values and looks for DOLLAR, WORD, OPENARRAY, CLOSEARRAY, etc., token values
     * and creates operation nodes, variable reference nodes, etc., using the return values from the parseOperation() and parseBottomLevel() methods.
     * @return either an empty Optional or it returns either an operation node or variable reference nodes.
     */

    Optional<Node> parseLValue() {
        Parser parser = new Parser(null);
        VariableReferenceNode variableReferenceNode = new VariableReferenceNode("", null);
        if (getTokenHandler().matchAndRemove(Token.TokenType.DOLLARSIGN).isPresent() && parseBottomLevel() == variableReferenceNode.getIndexExpression()) {
            OperationNode operationNode = new OperationNode(variableReferenceNode.getIndexExpression().get(), OperationNode.Operations.DOLLAR, null);
            return Optional.of(operationNode);
        }
        else if ((getTokenHandler().matchAndRemove(Token.TokenType.WORD).isPresent()) && variableReferenceNode.getVariableName().equals(OperationNode.Operations.OPENARRAY.name()) && (parser.parseOperation().isPresent() && variableReferenceNode.getVariableName().equals(OperationNode.Operations.CLOSEARRAY.name()))) {
            variableReferenceNode = new VariableReferenceNode(variableReferenceNode.getVariableName(), variableReferenceNode.getIndexExpression());
            return Optional.of(variableReferenceNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.WORD).isPresent() && !variableReferenceNode.getVariableName().equals(OperationNode.Operations.OPENARRAY.name())) {
            variableReferenceNode = new VariableReferenceNode(variableReferenceNode.getVariableName(), null);
            return Optional.of(variableReferenceNode);
        }
        else {
            return Optional.empty();
        }
    }

    /**
     * this parseAction() method returns false if it isn't an action. If it isn't a function, it creates
     * the FunctionDefinitionNode object, populates it with the name and parameters, and adds it to the list of functions for the program node.
     * @param programNode the method takes a program node as an argument and tries to parse it.
     * @return true if the actions were parsed and is an action, false otherwise.
     */

    public boolean parseAction(ProgramNode programNode) throws Exception {
        try {
            if (!getTokenHandler().matchAndRemove(Token.TokenType.BEGIN).isPresent() && !getTokenHandler().matchAndRemove(Token.TokenType.END).isPresent()) {
                setParseActionTrueFalse(false);
            }
            else {
                if (getTokenHandler().matchAndRemove(Token.TokenType.BEGIN).isPresent()) {
                    parseBlock();
                }
                else if (getTokenHandler().matchAndRemove(Token.TokenType.END).isPresent()) {
                    parseBlock();
                }
                else {
                    parseOperation();
                    programNode.setBlock(parseBlock());
                }
                setParseActionTrueFalse(true);
            }
        }
        catch (Exception e) {
            System.out.println("Error. There is neither no BEGIN nor END within the function.");
        }
        return getParseActionTrueFalse();
    }

    /**
     * this parseFunction() method returns false if it isn't a function. If it isn't a function, it creates
     * the FunctionDefinitionNode object, populates it with the name and parameters, and adds it to the list of functions for the program node.
     * @param programNode the method takes a program node as an argument and tries to parse it.
     * @return true if the actions were parsed and is a function, false otherwise.
     */

    public boolean parseFunction(ProgramNode programNode) {
        FunctionDefinitionNode functionDefinitionNode = new FunctionDefinitionNode(null, null, null);
        try {
            if (getTokenHandler().matchAndRemove(Token.TokenType.FUNCTION).isPresent()) {
                // look for left paren, and then the optional list of parameters and then a right paren before you create the function node
                if (getTokenHandler().matchAndRemove(Token.TokenType.LEFTPARENTHESIS).isPresent()) {
                    if (functionDefinitionNode.getParameterName() != null) {
                        if (getTokenHandler().matchAndRemove(Token.TokenType.RIGHTPARENTHESIS).isPresent()) {
                            functionDefinitionNode = new FunctionDefinitionNode(programNode.toString(), (Collection <Node>) programNode, null);
                        }
                    }
                }
                programNode.setFunctionDefinitionNode(functionDefinitionNode);
                parseBlock();
                setParseFunctionTrueFalse(true);
            }
        }
        catch (Exception e) {
            System.out.println("Error. The function could not be parsed because there either isn't a valid function name, left parenthesis, parameters or a right parenthesis.");
        }
        return getParseFunctionTrueFalse();
    }

    /**
     * this parseOperation() method tries to parse operations.
     * @return an Optional node.
     */

    Optional<Node> parseOperation() {
        try {
            parseTernary();
            if (getTokenHandler().matchAndRemove(Token.TokenType.PLUSEQUALS).isPresent()) {
                parseTernary();
            }
            else if (getTokenHandler().matchAndRemove(Token.TokenType.MINUSEQUALS).isPresent()) {
                parseTernary();
            }
            else if (getTokenHandler().matchAndRemove(Token.TokenType.EQUALS).isPresent()) {
                parseTernary();
            }
            else if (getTokenHandler().matchAndRemove(Token.TokenType.EXPONENTEQUALS).isPresent()) {
                parseTernary();
            }
            else if (getTokenHandler().matchAndRemove(Token.TokenType.PERCENTEQUALS).isPresent()) {
                parseTernary();
            }
            else if (getTokenHandler().matchAndRemove(Token.TokenType.MULTIPLYEQUALS).isPresent()) {
                parseTernary();
            }
            else if (getTokenHandler().matchAndRemove(Token.TokenType.DIVIDEEQUALS).isPresent()) {
                parseTernary();
            }
            return parseAssignment();
        }
        catch (Exception e) {
            System.out.println("Error. There was an error parsing this operation.");
        }
        return Optional.empty();
    }

    /**
     * this parseContinue() method tries to parse continue statements.
     * @return a node which is the continue statement.
     * @throws Exception throws an exception if the continue statement types couldn't be parsed.
     */

    public Node parseContinue() throws Exception {
        Node node;
        if (getTokenHandler().matchAndRemove(Token.TokenType.CONTINUE).isPresent()) {
            node = parseContinue();
        }
        else {
            throw new Exception();
        }
        return new ContinueNode(node);
    }

    /**
     * this parseBreak() method tries to parse break statements.
     * @return a node which is the break statement.
     * @throws Exception throws an exception if the break statement types couldn't be parsed.
     */

    public Node parseBreak() throws Exception {
        Node node;
        if (getTokenHandler().matchAndRemove(Token.TokenType.BREAK).isPresent()) {
            node = parseBreak();
        }
        else {
            throw new Exception();
        }
        return new BreakNode(node);
    }

    /**
     * this parseReturn() method tries to parse return statements.
     * @return a node which is the return statement.
     * @throws Exception throws an exception if the return statements couldn't be parsed.
     */
    public Node parseReturn() throws Exception {
        Node node;
        if (getTokenHandler().matchAndRemove(Token.TokenType.RETURN).isPresent()) {
            node = parseOperation().get();
        }
        else {
            throw new Exception();
        }
        return new ReturnNode(node);
    }

    /**
     * this parseIf() method tries to parse the different types of if statement types.
     * @return a node which is either one of the different types of if statement types.
     * @throws Exception throws an exception if either one of the different types of if statement types couldn't be parsed.
     */
    public Node parseIf() throws Exception {
        Node condition = parseOperation().get();
        Node block = parseBlock();
        Optional<Node> next;
        if (getTokenHandler().matchAndRemove(Token.TokenType.ELSE).isPresent()) {
            if (getTokenHandler().matchAndRemove(Token.TokenType.IF).isPresent()) {
                next = Optional.ofNullable(parseIf());
            }
            else {
                next = Optional.ofNullable(parseBlock());
            }
        }
        else {
            throw new Exception();
        }
        return new IfNode((BlockNode) condition, block, next.get());
    }

    /**
     * this parseFor() method tries to parse the two different types of for statement types.
     * @return a node which is either one of the two different types of for statement types.
     * @throws Exception throws an exception if either one of the two different types of for statement types couldn't be parsed.
     */
    public Node parseFor() throws Exception {
        StatementNode forNode = null, forEachNode = null;
        if (getTokenHandler().matchAndRemove(Token.TokenType.FOR).isPresent()) {
            if (getTokenHandler().matchAndRemove(Token.TokenType.LEFTPARENTHESIS).isPresent()) {
                forNode = (StatementNode) parseFor();
                if (getTokenHandler().matchAndRemove(Token.TokenType.RIGHTPARENTHESIS).isPresent()) {
                    return new ForNode(forNode, forEachNode);
                }
            }
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.FOREACH).isPresent()) {
            if (getTokenHandler().matchAndRemove(Token.TokenType.LEFTPARENTHESIS).isPresent()) {
                forEachNode = (StatementNode) parseFor();
                if (getTokenHandler().matchAndRemove(Token.TokenType.RIGHTPARENTHESIS).isPresent()) {
                    return new ForNode(forNode, forEachNode);
                }
            }
        }
        else {
            throw new Exception();
        }
        return null;
    }

    /**
     * this parseWhile() method tries to parse while statement types.
     * @return a node which is the while statement type.
     */
    public Node parseWhile() throws Exception {
        Node condition = parseOperation().get();
        Node block;
        if (getTokenHandler().matchAndRemove(Token.TokenType.WHILE).isPresent()) {
            if (getTokenHandler().matchAndRemove(Token.TokenType.LEFTPARENTHESIS).isPresent()) {
                block = parseBlock();
                if (getTokenHandler().matchAndRemove(Token.TokenType.RIGHTPARENTHESIS).isPresent()) {
                    return new WhileNode((BlockNode) condition, block);
                }
            }
        }
        else {
            throw new Exception();
        }
        return null;
    }

    /**
     * this parseDoWhile() method tries to parse do-while statement types.
     * @return a node which is the do-while statement type.
     */
    public Node parseDoWhile() throws Exception {
        Node condition = parseOperation().get();
        Node block;
        if (getTokenHandler().matchAndRemove(Token.TokenType.DO).isPresent()) {
            if (getTokenHandler().matchAndRemove(Token.TokenType.LEFTPARENTHESIS).isPresent()) {
                block = parseBlock();
                if (getTokenHandler().matchAndRemove(Token.TokenType.RIGHTPARENTHESIS).isPresent()) {
                    return new DoWhileNode((BlockNode) condition, block);
                }
            }
        }
        else {
            throw new Exception();
        }
        return null;
    }

    /**
     * this parseDelete() method tries to parse delete statement types.
     * @return a node which is the delete statement type.
     * @throws Exception throws an exception if the delete statement types couldn't be parsed.
     */
    public Node parseDelete() throws Exception {
        DeleteNode node;
        VariableReferenceNode variableReferenceNode;
        if (getTokenHandler().matchAndRemove(Token.TokenType.DELETE).isPresent()) {
            if (getTokenHandler().matchAndRemove(Token.TokenType.LEFTSQUAREBRACKET).isPresent()) {
                node = new DeleteNode(parseLValue().get().toString());
                variableReferenceNode = new VariableReferenceNode(node.getArrayReferenceName(), Optional.of(node));
                if (getTokenHandler().matchAndRemove(Token.TokenType.RIGHTSQUAREBRACKET).isPresent()) {
                    return new DeleteNode(variableReferenceNode.toString());
                }
            }
        }
        else {
            throw new Exception();
        }
        return null;
    }

    /**
     * this parseFunctionCall() method tries to parse a function call.
     * @return a node which is the function call.
     * @throws Exception throws an exception if it doesn't succeed in returning the node.
     */

    public Node parseFunctionCall() throws Exception {
        Node node = null;
        LinkedList<Node> parameter = new LinkedList<>();
        if (getTokenHandler().matchAndRemove(Token.TokenType.FUNCTION).isPresent()) {
            if (getTokenHandler().matchAndRemove(Token.TokenType.LEFTPARENTHESIS).isPresent()) {
                node = parseOperation().get();
            }
            else if (getTokenHandler().matchAndRemove(Token.TokenType.RIGHTPARENTHESIS).isPresent()) {
                parameter.add(parseBlock());
            }
            else {
                throw new Exception();
            }
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.GETLINE).isPresent()) {
            node = parseOperation().get();
            parameter.add(parseBlock());
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.PRINT).isPresent()) {
            node = parseOperation().get();
            parameter.add(parseBlock());
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.PRINTF).isPresent()) {
            node = parseOperation().get();
            parameter.add(parseBlock());
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.EXIT).isPresent()) {
            node = parseOperation().get();
            parameter.add(parseBlock());
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.NEXTFILE).isPresent()) {
            node = parseOperation().get();
            parameter.add(parseBlock());
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.NEXT).isPresent()) {
            node = parseOperation().get();
            parameter.add(parseBlock());
        }
        else {
            throw new Exception();
        }
        return new FunctionCallNode(node, parameter);
    }

    /**
     * this parseStatement() method tries to parse statements, and it returns the first one that succeeds.
     * @return the first statement that succeeds.
     * @throws Exception throws an exception if it doesn't succeed which means any one of the statement types couldn't be parsed.
     */

    public Optional<StatementNode> parseStatement() throws Exception {
        StatementNode statementNode;
        if (getTokenHandler().matchAndRemove(Token.TokenType.CONTINUE).isPresent()) {
            statementNode = (StatementNode) parseContinue();
            return Optional.ofNullable(statementNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.BREAK).isPresent()) {
            statementNode = (StatementNode) parseBreak();
            return Optional.ofNullable(statementNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.IF).isPresent()) {
            statementNode = (StatementNode) parseIf();
            return Optional.ofNullable(statementNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.FOR).isPresent()) {
            statementNode = (StatementNode) parseFor();
            return Optional.ofNullable(statementNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.DELETE).isPresent()) {
            statementNode = (StatementNode) parseDelete();
            return Optional.ofNullable(statementNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.WHILE).isPresent()) {
            statementNode = (StatementNode) parseWhile();
            return Optional.ofNullable(statementNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.DO).isPresent()) {
            statementNode = (StatementNode) parseDoWhile();
            return Optional.ofNullable(statementNode);
        }
        else if (getTokenHandler().matchAndRemove(Token.TokenType.RETURN).isPresent()) {
            statementNode = (StatementNode) parseReturn();
            return Optional.ofNullable(statementNode);
        }
        else {
            throw new Exception();
        }
    }

    /**
     * this parseBlock() method tries to parse blocks.
     * @return a new block node for now.
     * @throws Exception throws an exception if the block couldn't be parsed.
     */

    public BlockNode parseBlock() throws Exception {
        if (!getTokenHandler().matchAndRemove(Token.TokenType.BEGIN).isPresent()) {
            return null;
        }
        LinkedList<StatementNode> statementNodes = new LinkedList<>();
        StatementNode stateNode;
        if (!getTokenHandler().matchAndRemove(Token.TokenType.LEFTCURLYBRACE).isPresent()) {
            return null;
        }
        else {
            if (getTokenHandler().matchAndRemove(Token.TokenType.LEFTCURLYBRACE).isPresent()) {
                if (acceptSeparators(getTokenHandler().matchAndRemove(Token.TokenType.LEFTCURLYBRACE).toString().length())) {
                    statementNodes.add(parseStatement().get());
                }
            }
            else if (getTokenHandler().matchAndRemove(Token.TokenType.RIGHTCURLYBRACE).isPresent()) {
                if (acceptSeparators(getTokenHandler().matchAndRemove(Token.TokenType.RIGHTCURLYBRACE).toString().length())) {
                    statementNodes.add(parseStatement().get());
                }
            }
        }
        do {
            stateNode = parseStatement().get();
            if (stateNode != null) {
                statementNodes.add(stateNode);
                if (!getTokenHandler().matchAndRemove(Token.TokenType.RIGHTCURLYBRACE).isPresent()) {
                    break;
                }
            }
        } while (parseStatement().isPresent());
        if (!getTokenHandler().matchAndRemove(Token.TokenType.END).isPresent()) {
            throw new Exception();
        }
        return new BlockNode(statementNodes, null);
    }
}